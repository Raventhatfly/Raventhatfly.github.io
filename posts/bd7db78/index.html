<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Lecture2 - Feiyang Wu Personal Page</title><meta name=author content="Feiyang Wu">
<meta name=author-link content><meta name=description content="C / C++ 编译原理
  
    
  
需要提前掌握的基础知识
  
    
  

比特和字节的关系，8bit = 1B
十六进制数的表达方式以及十六进制数和二进制数的转换

例子：0x2f = 00101111



预习内容
  
    
  
1. 中央处理器（CPU）架构
  
    
  
内存
  
    
  
内存是计算机的存储空间。
对于很多没有接触过计算机的人来说，内存=硬盘。其实这种理解是错误的。内存掉电会丢失内容，而
硬盘在掉电之后信息不会丢失。但是内存的访问速度比硬盘快，因此实际上在电脑启动时操作系统的代码
会从硬盘上搬迁到内存里。平时打开的文件也是如此。
内存地址的基本单位是字节。一个字节=8比特。对于32位计算机，其寻址能力为32位，意思是有2^32个
地址。大部分计算机是字节寻址，即一个地址对应一个字节的数据（ECE120涉及的LC3是16位机，但是
一个地址对应2B两个字节的数据）。
其他
  
    
  
交给ECE120去学吧。
2. 编译流程
  
    
  
常见概念
  
    
  
头文件.h包含了函数声明、宏定义等。在C++当中还会存放类。.c文件中存放源代码。
具体流程
  
    
  
(a)预处理阶段
  
    
  
预处理阶段，其实用朴素的话语来讲就是对宏（Macro）进行文本替换或展开。例如：


1


#include <stdio.h>

在预处理完成之后，这段代码会被直接替换位stdio.h头文件包含的内容。
再例如：


1


#define GPIO_DEVICE_ID 1

代码里所有出现的GPIO_DEVICE_ID将被替换为1。

    
      注意
    
    
      当使用#include之后，就可以使用头文件里的宏。除非是编译器定义的宏，否则可能会无法被找到。
    
  
(b)编译阶段
  
    
  
将所有预处理之后的C/C++代码翻译成汇编语言(汇编文件一般以.s,.asm为后缀，将会在ECE120
后期课程涉及)。
(c)汇编阶段
  
    
  
将汇编语言翻译成计算机可执行的二进制文件(生成若干.o，.obj文件)。每个独立的二进制文件
由于不知道相互之间的关系，现在还无法独立运行。
(d)链接阶段
  
    
  
这个阶段是最令人头大阶段。链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件
(executable file)。该过程较为复杂，希望详细了解可以阅读知乎文章。
通俗易懂的讲法，就是把每个C/C++文件生成的二进制文件，或者一些厂商（例如Windows）提供的
二进制文件（即静态与动态链接库，常见后缀.so，.lib，.a）组装在一起。
静态链接库：当要使用时，连接器(linker)会找出程序所需的函数，然后将它们拷贝到执行文件，
由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。
动态库链接库：某个程序在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存里是否已有此库函数的拷贝了。
如果有，则让其共享那一个拷贝；只有没有才链接载入
常见错误：
如果使用一个函数但没有定义它（大部分时候有可能是函数单纯打错了）：

    
      Failure
    
    
      link_example.c:(.text+0xe): undefined reference to `foo'
collect2.exe: error: ld returned 1 exit status
    
  
如果链接器发现了两个不同的二进制文件中有相同的全局变量或函数，连接器会这么报错：

    
      Failure
    
    
      /tmp/ccIa32rv.o:(.bss+0x0): multiple definition of head'/tmp/ccAvumDO.o:(.bss+0x0): first defined here /tmp/ccuVImET.o:(.bss+0x0): multiple definition of head'
/tmp/ccAvumDO.o:(.bss+0x0): first defined here
collect2: error: ld returned 1 exit status
    
  
3. 编译脚本
  
    
  
脚本(sript)就是把一些命令放在一个文件里，这样在执行的时候不需要一条条手动输入而是一次性
全部执行的一个文件。
编程语言也主要分为两种：编译语言与脚本语言。脚本语言的每一条代码逐条投喂至解释器，并理解
翻译成二进制代码供CPU执行。而编译语言将全部代码全部翻译为二进制代码之后才能供CPU执行。
最常见的脚本语言是Python。最典型的编译语言即为C和C++。
Makefile
  
    
  
Makefile 是一个用于管理项目构建的文件，通常用于编译和链接程序，特别是在大型项目中。
它通过定义一系列规则和目标，自动化了编译和构建过程，从而避免了手动输入复杂的编译命令。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


# 定义变量
CC = gcc
CFLAGS = -Wall -g

# 定义目标文件
TARGET = myprogram

# 定义依赖关系和规则
$(TARGET): main.o utils.o
    $(CC) $(CFLAGS) -o $(TARGET) main.o utils.o

main.o: main.c
    $(CC) $(CFLAGS) -c main.c

utils.o: utils.c
    $(CC) $(CFLAGS) -c utils.c

# 伪目标，用于清理构建文件
.PHONY: clean
clean:
    rm -f $(TARGET) *.o


找到项目的Makefile文件，打开终端输入：


1


make

make将根据Makefile生成gcc指令。例如上述代码的运行路径为中的文件有：


1
2
3
4


my_project/
├── Makefile
├── main.c
└── utils.c

$(CC)会被翻译成gcc，$(CFLAGS)会被翻译成-Wall -g。-o 我们在之前介绍过，是输出的意思。
所以如果输入make myprogram实际上相当于输入了以下的gcc指令：


1
2
3


gcc -Wall -g -c main.c # 将main.c编译为main.o
gcc -Wall -g -c utils.c
gcc -Wall -g -o myprogram main.o utils.o # 通过.o文件生成myprogram可执行文件

CMake
  
    
  
CMake 是一个跨台的构建系统，它用于管理项目的编译过程，生成特定于平台的构建文件（如
Makefile、Visual Studio 项目文件等）。CMake 通过一种高级脚本语言来描述构建过程，
能够更好地处理复杂的构建需求，并且在不同平台之间保持一致性。在我们的项目中我们一般使用
Cmake来生成Makefile。
假设现在我们的项目文件夹为：


1
2
3
4


my_project/
├── CMakeLists.txt
├── main.cpp
└── utils.cpp

CMakeLists.txt：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


cmake_minimum_required(VERSION 3.10)

# 项目信息
project(MyProject)

# 设置 C++ 标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# 添加可执行文件
add_executable(MyProject main.cpp utils.cpp)

然后运行：


1
2
3


mkdir build
cd build
cmake ..  # .. 表示上一级目录，这里的意思是Cmakelists.txt在上一级目录

然后我们就能在build文件夹中找到Makefile了。此时我们就能运行：


1


make

我们就能得到想要的二进制可执行文件了。
课后作业
  
    
  

使用Makefile和Cmake成功编译文件。
继续观看黑马程序员教学视频。

"><meta name=keywords content='meta-teaching'><meta itemprop=name content="Lecture2"><meta itemprop=description content="C / C++ 编译原理
  
    
  
需要提前掌握的基础知识
  
    
  

比特和字节的关系，8bit = 1B
十六进制数的表达方式以及十六进制数和二进制数的转换

例子：0x2f = 00101111



预习内容
  
    
  
1. 中央处理器（CPU）架构
  
    
  
内存
  
    
  
内存是计算机的存储空间。
对于很多没有接触过计算机的人来说，内存=硬盘。其实这种理解是错误的。内存掉电会丢失内容，而
硬盘在掉电之后信息不会丢失。但是内存的访问速度比硬盘快，因此实际上在电脑启动时操作系统的代码
会从硬盘上搬迁到内存里。平时打开的文件也是如此。
内存地址的基本单位是字节。一个字节=8比特。对于32位计算机，其寻址能力为32位，意思是有2^32个
地址。大部分计算机是字节寻址，即一个地址对应一个字节的数据（ECE120涉及的LC3是16位机，但是
一个地址对应2B两个字节的数据）。
其他
  
    
  
交给ECE120去学吧。
2. 编译流程
  
    
  
常见概念
  
    
  
头文件.h包含了函数声明、宏定义等。在C++当中还会存放类。.c文件中存放源代码。
具体流程
  
    
  
(a)预处理阶段
  
    
  
预处理阶段，其实用朴素的话语来讲就是对宏（Macro）进行文本替换或展开。例如：


1


#include <stdio.h>

在预处理完成之后，这段代码会被直接替换位stdio.h头文件包含的内容。
再例如：


1


#define GPIO_DEVICE_ID 1

代码里所有出现的GPIO_DEVICE_ID将被替换为1。

    
      注意
    
    
      当使用#include之后，就可以使用头文件里的宏。除非是编译器定义的宏，否则可能会无法被找到。
    
  
(b)编译阶段
  
    
  
将所有预处理之后的C/C++代码翻译成汇编语言(汇编文件一般以.s,.asm为后缀，将会在ECE120
后期课程涉及)。
(c)汇编阶段
  
    
  
将汇编语言翻译成计算机可执行的二进制文件(生成若干.o，.obj文件)。每个独立的二进制文件
由于不知道相互之间的关系，现在还无法独立运行。
(d)链接阶段
  
    
  
这个阶段是最令人头大阶段。链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件
(executable file)。该过程较为复杂，希望详细了解可以阅读知乎文章。
通俗易懂的讲法，就是把每个C/C++文件生成的二进制文件，或者一些厂商（例如Windows）提供的
二进制文件（即静态与动态链接库，常见后缀.so，.lib，.a）组装在一起。
静态链接库：当要使用时，连接器(linker)会找出程序所需的函数，然后将它们拷贝到执行文件，
由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。
动态库链接库：某个程序在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存里是否已有此库函数的拷贝了。
如果有，则让其共享那一个拷贝；只有没有才链接载入
常见错误：
如果使用一个函数但没有定义它（大部分时候有可能是函数单纯打错了）：

    
      Failure
    
    
      link_example.c:(.text+0xe): undefined reference to `foo'
collect2.exe: error: ld returned 1 exit status
    
  
如果链接器发现了两个不同的二进制文件中有相同的全局变量或函数，连接器会这么报错：

    
      Failure
    
    
      /tmp/ccIa32rv.o:(.bss+0x0): multiple definition of head'/tmp/ccAvumDO.o:(.bss+0x0): first defined here /tmp/ccuVImET.o:(.bss+0x0): multiple definition of head'
/tmp/ccAvumDO.o:(.bss+0x0): first defined here
collect2: error: ld returned 1 exit status
    
  
3. 编译脚本
  
    
  
脚本(sript)就是把一些命令放在一个文件里，这样在执行的时候不需要一条条手动输入而是一次性
全部执行的一个文件。
编程语言也主要分为两种：编译语言与脚本语言。脚本语言的每一条代码逐条投喂至解释器，并理解
翻译成二进制代码供CPU执行。而编译语言将全部代码全部翻译为二进制代码之后才能供CPU执行。
最常见的脚本语言是Python。最典型的编译语言即为C和C++。
Makefile
  
    
  
Makefile 是一个用于管理项目构建的文件，通常用于编译和链接程序，特别是在大型项目中。
它通过定义一系列规则和目标，自动化了编译和构建过程，从而避免了手动输入复杂的编译命令。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


# 定义变量
CC = gcc
CFLAGS = -Wall -g

# 定义目标文件
TARGET = myprogram

# 定义依赖关系和规则
$(TARGET): main.o utils.o
    $(CC) $(CFLAGS) -o $(TARGET) main.o utils.o

main.o: main.c
    $(CC) $(CFLAGS) -c main.c

utils.o: utils.c
    $(CC) $(CFLAGS) -c utils.c

# 伪目标，用于清理构建文件
.PHONY: clean
clean:
    rm -f $(TARGET) *.o


找到项目的Makefile文件，打开终端输入：


1


make

make将根据Makefile生成gcc指令。例如上述代码的运行路径为中的文件有：


1
2
3
4


my_project/
├── Makefile
├── main.c
└── utils.c

$(CC)会被翻译成gcc，$(CFLAGS)会被翻译成-Wall -g。-o 我们在之前介绍过，是输出的意思。
所以如果输入make myprogram实际上相当于输入了以下的gcc指令：


1
2
3


gcc -Wall -g -c main.c # 将main.c编译为main.o
gcc -Wall -g -c utils.c
gcc -Wall -g -o myprogram main.o utils.o # 通过.o文件生成myprogram可执行文件

CMake
  
    
  
CMake 是一个跨台的构建系统，它用于管理项目的编译过程，生成特定于平台的构建文件（如
Makefile、Visual Studio 项目文件等）。CMake 通过一种高级脚本语言来描述构建过程，
能够更好地处理复杂的构建需求，并且在不同平台之间保持一致性。在我们的项目中我们一般使用
Cmake来生成Makefile。
假设现在我们的项目文件夹为：


1
2
3
4


my_project/
├── CMakeLists.txt
├── main.cpp
└── utils.cpp

CMakeLists.txt：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


cmake_minimum_required(VERSION 3.10)

# 项目信息
project(MyProject)

# 设置 C++ 标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# 添加可执行文件
add_executable(MyProject main.cpp utils.cpp)

然后运行：


1
2
3


mkdir build
cd build
cmake ..  # .. 表示上一级目录，这里的意思是Cmakelists.txt在上一级目录

然后我们就能在build文件夹中找到Makefile了。此时我们就能运行：


1


make

我们就能得到想要的二进制可执行文件了。
课后作业
  
    
  

使用Makefile和Cmake成功编译文件。
继续观看黑马程序员教学视频。

"><meta itemprop=datePublished content="2024-05-15T09:15:14-05:00"><meta itemprop=dateModified content="2024-05-16T00:08:52-05:00"><meta itemprop=wordCount content="294"><meta itemprop=keywords content="Meta-Teaching"><meta property="og:url" content="https://Raventhatfly.github.io/posts/bd7db78/"><meta property="og:site_name" content="Feiyang Wu Personal Page"><meta property="og:title" content="Lecture2"><meta property="og:description" content="C / C++ 编译原理 需要提前掌握的基础知识 比特和字节的关系，8bit = 1B 十六进制数的表达方式以及十六进制数和二进制数的转换 例子：0x2f = 00101111 预习内容 1. 中央处理器（CPU）架构 内存 内存是计算机的存储空间。
对于很多没有接触过计算机的人来说，内存=硬盘。其实这种理解是错误的。内存掉电会丢失内容，而 硬盘在掉电之后信息不会丢失。但是内存的访问速度比硬盘快，因此实际上在电脑启动时操作系统的代码 会从硬盘上搬迁到内存里。平时打开的文件也是如此。
内存地址的基本单位是字节。一个字节=8比特。对于32位计算机，其寻址能力为32位，意思是有2^32个 地址。大部分计算机是字节寻址，即一个地址对应一个字节的数据（ECE120涉及的LC3是16位机，但是 一个地址对应2B两个字节的数据）。
其他 交给ECE120去学吧。
2. 编译流程 常见概念 头文件.h包含了函数声明、宏定义等。在C++当中还会存放类。.c文件中存放源代码。
具体流程 (a)预处理阶段 预处理阶段，其实用朴素的话语来讲就是对宏（Macro）进行文本替换或展开。例如：
1 #include <stdio.h> 在预处理完成之后，这段代码会被直接替换位stdio.h头文件包含的内容。 再例如：
1 #define GPIO_DEVICE_ID 1 代码里所有出现的GPIO_DEVICE_ID将被替换为1。
注意 当使用#include之后，就可以使用头文件里的宏。除非是编译器定义的宏，否则可能会无法被找到。 (b)编译阶段 将所有预处理之后的C/C++代码翻译成汇编语言(汇编文件一般以.s,.asm为后缀，将会在ECE120 后期课程涉及)。
(c)汇编阶段 将汇编语言翻译成计算机可执行的二进制文件(生成若干.o，.obj文件)。每个独立的二进制文件 由于不知道相互之间的关系，现在还无法独立运行。
(d)链接阶段 这个阶段是最令人头大阶段。链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件 (executable file)。该过程较为复杂，希望详细了解可以阅读知乎文章。 通俗易懂的讲法，就是把每个C/C++文件生成的二进制文件，或者一些厂商（例如Windows）提供的 二进制文件（即静态与动态链接库，常见后缀.so，.lib，.a）组装在一起。
静态链接库：当要使用时，连接器(linker)会找出程序所需的函数，然后将它们拷贝到执行文件， 由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。
动态库链接库：某个程序在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存里是否已有此库函数的拷贝了。 如果有，则让其共享那一个拷贝；只有没有才链接载入
常见错误：
如果使用一个函数但没有定义它（大部分时候有可能是函数单纯打错了）： Failure link_example.c:(.text+0xe): undefined reference to `foo' collect2.exe: error: ld returned 1 exit status 如果链接器发现了两个不同的二进制文件中有相同的全局变量或函数，连接器会这么报错： Failure /tmp/ccIa32rv.o:(.bss+0x0): multiple definition of head'/tmp/ccAvumDO.o:(.bss+0x0): first defined here /tmp/ccuVImET.o:(.bss+0x0): multiple definition of head' /tmp/ccAvumDO.o:(.bss+0x0): first defined here collect2: error: ld returned 1 exit status 3. 编译脚本 脚本(sript)就是把一些命令放在一个文件里，这样在执行的时候不需要一条条手动输入而是一次性 全部执行的一个文件。
编程语言也主要分为两种：编译语言与脚本语言。脚本语言的每一条代码逐条投喂至解释器，并理解 翻译成二进制代码供CPU执行。而编译语言将全部代码全部翻译为二进制代码之后才能供CPU执行。 最常见的脚本语言是Python。最典型的编译语言即为C和C++。
Makefile Makefile 是一个用于管理项目构建的文件，通常用于编译和链接程序，特别是在大型项目中。 它通过定义一系列规则和目标，自动化了编译和构建过程，从而避免了手动输入复杂的编译命令。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 定义变量 CC = gcc CFLAGS = -Wall -g # 定义目标文件 TARGET = myprogram # 定义依赖关系和规则 $(TARGET): main.o utils.o $(CC) $(CFLAGS) -o $(TARGET) main.o utils.o main.o: main.c $(CC) $(CFLAGS) -c main.c utils.o: utils.c $(CC) $(CFLAGS) -c utils.c # 伪目标，用于清理构建文件 .PHONY: clean clean: rm -f $(TARGET) *.o 找到项目的Makefile文件，打开终端输入：
1 make make将根据Makefile生成gcc指令。例如上述代码的运行路径为中的文件有：
1 2 3 4 my_project/ ├── Makefile ├── main.c └── utils.c $(CC)会被翻译成gcc，$(CFLAGS)会被翻译成-Wall -g。-o 我们在之前介绍过，是输出的意思。 所以如果输入make myprogram实际上相当于输入了以下的gcc指令：
1 2 3 gcc -Wall -g -c main.c # 将main.c编译为main.o gcc -Wall -g -c utils.c gcc -Wall -g -o myprogram main.o utils.o # 通过.o文件生成myprogram可执行文件 CMake CMake 是一个跨台的构建系统，它用于管理项目的编译过程，生成特定于平台的构建文件（如 Makefile、Visual Studio 项目文件等）。CMake 通过一种高级脚本语言来描述构建过程， 能够更好地处理复杂的构建需求，并且在不同平台之间保持一致性。在我们的项目中我们一般使用 Cmake来生成Makefile。
假设现在我们的项目文件夹为：
1 2 3 4 my_project/ ├── CMakeLists.txt ├── main.cpp └── utils.cpp CMakeLists.txt：
1 2 3 4 5 6 7 8 9 10 11 cmake_minimum_required(VERSION 3.10) # 项目信息 project(MyProject) # 设置 C++ 标准 set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True) # 添加可执行文件 add_executable(MyProject main.cpp utils.cpp) 然后运行：
1 2 3 mkdir build cd build cmake .. # .. 表示上一级目录，这里的意思是Cmakelists.txt在上一级目录 然后我们就能在build文件夹中找到Makefile了。此时我们就能运行：
1 make 我们就能得到想要的二进制可执行文件了。
课后作业 使用Makefile和Cmake成功编译文件。 继续观看黑马程序员教学视频。 "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-05-15T09:15:14-05:00"><meta property="article:modified_time" content="2024-05-16T00:08:52-05:00"><meta property="article:tag" content="Meta-Teaching"><meta name=twitter:card content="summary"><meta name=twitter:title content="Lecture2"><meta name=twitter:description content="C / C++ 编译原理
  
    
  
需要提前掌握的基础知识
  
    
  

比特和字节的关系，8bit = 1B
十六进制数的表达方式以及十六进制数和二进制数的转换

例子：0x2f = 00101111



预习内容
  
    
  
1. 中央处理器（CPU）架构
  
    
  
内存
  
    
  
内存是计算机的存储空间。
对于很多没有接触过计算机的人来说，内存=硬盘。其实这种理解是错误的。内存掉电会丢失内容，而
硬盘在掉电之后信息不会丢失。但是内存的访问速度比硬盘快，因此实际上在电脑启动时操作系统的代码
会从硬盘上搬迁到内存里。平时打开的文件也是如此。
内存地址的基本单位是字节。一个字节=8比特。对于32位计算机，其寻址能力为32位，意思是有2^32个
地址。大部分计算机是字节寻址，即一个地址对应一个字节的数据（ECE120涉及的LC3是16位机，但是
一个地址对应2B两个字节的数据）。
其他
  
    
  
交给ECE120去学吧。
2. 编译流程
  
    
  
常见概念
  
    
  
头文件.h包含了函数声明、宏定义等。在C++当中还会存放类。.c文件中存放源代码。
具体流程
  
    
  
(a)预处理阶段
  
    
  
预处理阶段，其实用朴素的话语来讲就是对宏（Macro）进行文本替换或展开。例如：


1


#include <stdio.h>

在预处理完成之后，这段代码会被直接替换位stdio.h头文件包含的内容。
再例如：


1


#define GPIO_DEVICE_ID 1

代码里所有出现的GPIO_DEVICE_ID将被替换为1。

    
      注意
    
    
      当使用#include之后，就可以使用头文件里的宏。除非是编译器定义的宏，否则可能会无法被找到。
    
  
(b)编译阶段
  
    
  
将所有预处理之后的C/C++代码翻译成汇编语言(汇编文件一般以.s,.asm为后缀，将会在ECE120
后期课程涉及)。
(c)汇编阶段
  
    
  
将汇编语言翻译成计算机可执行的二进制文件(生成若干.o，.obj文件)。每个独立的二进制文件
由于不知道相互之间的关系，现在还无法独立运行。
(d)链接阶段
  
    
  
这个阶段是最令人头大阶段。链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件
(executable file)。该过程较为复杂，希望详细了解可以阅读知乎文章。
通俗易懂的讲法，就是把每个C/C++文件生成的二进制文件，或者一些厂商（例如Windows）提供的
二进制文件（即静态与动态链接库，常见后缀.so，.lib，.a）组装在一起。
静态链接库：当要使用时，连接器(linker)会找出程序所需的函数，然后将它们拷贝到执行文件，
由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。
动态库链接库：某个程序在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存里是否已有此库函数的拷贝了。
如果有，则让其共享那一个拷贝；只有没有才链接载入
常见错误：
如果使用一个函数但没有定义它（大部分时候有可能是函数单纯打错了）：

    
      Failure
    
    
      link_example.c:(.text+0xe): undefined reference to `foo'
collect2.exe: error: ld returned 1 exit status
    
  
如果链接器发现了两个不同的二进制文件中有相同的全局变量或函数，连接器会这么报错：

    
      Failure
    
    
      /tmp/ccIa32rv.o:(.bss+0x0): multiple definition of head'/tmp/ccAvumDO.o:(.bss+0x0): first defined here /tmp/ccuVImET.o:(.bss+0x0): multiple definition of head'
/tmp/ccAvumDO.o:(.bss+0x0): first defined here
collect2: error: ld returned 1 exit status
    
  
3. 编译脚本
  
    
  
脚本(sript)就是把一些命令放在一个文件里，这样在执行的时候不需要一条条手动输入而是一次性
全部执行的一个文件。
编程语言也主要分为两种：编译语言与脚本语言。脚本语言的每一条代码逐条投喂至解释器，并理解
翻译成二进制代码供CPU执行。而编译语言将全部代码全部翻译为二进制代码之后才能供CPU执行。
最常见的脚本语言是Python。最典型的编译语言即为C和C++。
Makefile
  
    
  
Makefile 是一个用于管理项目构建的文件，通常用于编译和链接程序，特别是在大型项目中。
它通过定义一系列规则和目标，自动化了编译和构建过程，从而避免了手动输入复杂的编译命令。


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21


# 定义变量
CC = gcc
CFLAGS = -Wall -g

# 定义目标文件
TARGET = myprogram

# 定义依赖关系和规则
$(TARGET): main.o utils.o
    $(CC) $(CFLAGS) -o $(TARGET) main.o utils.o

main.o: main.c
    $(CC) $(CFLAGS) -c main.c

utils.o: utils.c
    $(CC) $(CFLAGS) -c utils.c

# 伪目标，用于清理构建文件
.PHONY: clean
clean:
    rm -f $(TARGET) *.o


找到项目的Makefile文件，打开终端输入：


1


make

make将根据Makefile生成gcc指令。例如上述代码的运行路径为中的文件有：


1
2
3
4


my_project/
├── Makefile
├── main.c
└── utils.c

$(CC)会被翻译成gcc，$(CFLAGS)会被翻译成-Wall -g。-o 我们在之前介绍过，是输出的意思。
所以如果输入make myprogram实际上相当于输入了以下的gcc指令：


1
2
3


gcc -Wall -g -c main.c # 将main.c编译为main.o
gcc -Wall -g -c utils.c
gcc -Wall -g -o myprogram main.o utils.o # 通过.o文件生成myprogram可执行文件

CMake
  
    
  
CMake 是一个跨台的构建系统，它用于管理项目的编译过程，生成特定于平台的构建文件（如
Makefile、Visual Studio 项目文件等）。CMake 通过一种高级脚本语言来描述构建过程，
能够更好地处理复杂的构建需求，并且在不同平台之间保持一致性。在我们的项目中我们一般使用
Cmake来生成Makefile。
假设现在我们的项目文件夹为：


1
2
3
4


my_project/
├── CMakeLists.txt
├── main.cpp
└── utils.cpp

CMakeLists.txt：


 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11


cmake_minimum_required(VERSION 3.10)

# 项目信息
project(MyProject)

# 设置 C++ 标准
set(CMAKE_CXX_STANDARD 11)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# 添加可执行文件
add_executable(MyProject main.cpp utils.cpp)

然后运行：


1
2
3


mkdir build
cd build
cmake ..  # .. 表示上一级目录，这里的意思是Cmakelists.txt在上一级目录

然后我们就能在build文件夹中找到Makefile了。此时我们就能运行：


1


make

我们就能得到想要的二进制可执行文件了。
课后作业
  
    
  

使用Makefile和Cmake成功编译文件。
继续观看黑马程序员教学视频。

"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://Raventhatfly.github.io/posts/bd7db78/><link rel=prev href=https://Raventhatfly.github.io/posts/574de11/><link rel=next href=https://Raventhatfly.github.io/posts/2e8f072/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Lecture2","inLanguage":"en-us","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/Raventhatfly.github.io\/posts\/bd7db78\/"},"genre":"posts","keywords":"meta-teaching","wordcount":294,"url":"https:\/\/Raventhatfly.github.io\/posts\/bd7db78\/","datePublished":"2024-05-15T09:15:14-05:00","dateModified":"2024-05-16T00:08:52-05:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Feiyang Wu"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title="Feiyang Wu Personal Page"><span class=header-title-text>Feiyang Wu Personal Page</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class="menu-item has-children"><a class=menu-link href=/><i class="fa-solid fa-list fa-fw fa-sm" aria-hidden=true></i> Info</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/meta-teaching/main/><i class="fa-solid fa-chalkboard fa-fw fa-sm" aria-hidden=true></i> Meta Teaching</a></li><li class=menu-item><a class=menu-link href=https://zjui.intl.zju.edu.cn/ rel="noopener noreferrer" target=_blank><i class="fa-solid fa-university fa-fw fa-sm" aria-hidden=true></i> ZJU-UIUC</a></li><li class=menu-item><a class=menu-link href=https://illinois.edu/ rel="noopener noreferrer" target=_blank><i class="fa-solid fa-school fa-fw fa-sm" aria-hidden=true></i> UIUC</a></li><li class=menu-item><a class=menu-link href=/files/profile/resume_zh_cn.pdf><i class="fa-solid fa-paper-plane fa-fw fa-sm" aria-hidden=true></i> Chinese Profile</a></li><li class=menu-item><a class=menu-link href=/files/profile/resume_en.pdf><i class="fa-solid fa-paperclip fa-fw fa-sm" aria-hidden=true></i> English Profile</a></li></ul></li><li class=menu-item><a class=menu-link href=/profile/><i class="fa-solid fa-house fa-fw fa-sm" aria-hidden=true></i> Profile</a></li><li class="menu-item delimiter"></li><li class="menu-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Feiyang Wu Personal Page"><span class=header-title-text>Feiyang Wu Personal Page</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=menu-item><a class=menu-link href=/archives/><i class="fa-solid fa-archive fa-fw fa-sm" aria-hidden=true></i> Archives</a></li><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> Categories</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> Tags</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/><i class="fa-solid fa-list fa-fw fa-sm" aria-hidden=true></i> Info</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/meta-teaching/main/><i class="fa-solid fa-chalkboard fa-fw fa-sm" aria-hidden=true></i> Meta Teaching</a></li><li class=menu-item><a class=menu-link href=https://zjui.intl.zju.edu.cn/ rel="noopener noreferrer" target=_blank><i class="fa-solid fa-university fa-fw fa-sm" aria-hidden=true></i> ZJU-UIUC</a></li><li class=menu-item><a class=menu-link href=https://illinois.edu/ rel="noopener noreferrer" target=_blank><i class="fa-solid fa-school fa-fw fa-sm" aria-hidden=true></i> UIUC</a></li><li class=menu-item><a class=menu-link href=/files/profile/resume_zh_cn.pdf><i class="fa-solid fa-paper-plane fa-fw fa-sm" aria-hidden=true></i> Chinese Profile</a></li><li class=menu-item><a class=menu-link href=/files/profile/resume_en.pdf><i class="fa-solid fa-paperclip fa-fw fa-sm" aria-hidden=true></i> English Profile</a></li></ul></li><li class=menu-item><a class=menu-link href=/profile/><i class="fa-solid fa-house fa-fw fa-sm" aria-hidden=true></i> Profile</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><main class="container container-reverse"><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=Collections></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span title=Repost class=icon-repost><i class="fa-solid fa-share fa-fw" aria-hidden=true></i></span><span>Lecture2</span></h1><p class="single-subtitle animate__animated animate__fadeIn">Meta电控培训【第二讲】</p></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><img loading=lazy src=/avatar_img/avatar.jpg alt="Feiyang Wu" data-title="Feiyang Wu" class=avatar style="background:url(/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'>&nbsp;Feiyang Wu</span></span><span class=post-included-in>&nbsp;included in <a href=/categories/meta-teaching/ class=post-category title="Category - Meta-Teaching"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Meta-Teaching</a></span></div><div class=post-meta-line><span title="published on 2024-05-15 09:15:14"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2024-05-15>2024-05-15</time></span>&nbsp;<span title="Updated on 2024-05-16 00:08:52"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-05-16>2024-05-16</time></span>&nbsp;<span title="294 words"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>About 300 words</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>2 minutes</span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#需要提前掌握的基础知识>需要提前掌握的基础知识</a></li><li><a href=#预习内容>预习内容</a></li><li><a href=#1-中央处理器cpu架构>1. 中央处理器（CPU）架构</a></li><li><a href=#2-编译流程>2. 编译流程</a></li><li><a href=#3-编译脚本>3. 编译脚本</a></li><li><a href=#课后作业>课后作业</a></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=c--c-编译原理 class=heading-element><span>C / C++ 编译原理</span>
<a href=#c--c-%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h1><h3 id=需要提前掌握的基础知识 class=heading-element><span>需要提前掌握的基础知识</span>
<a href=#%e9%9c%80%e8%a6%81%e6%8f%90%e5%89%8d%e6%8e%8c%e6%8f%a1%e7%9a%84%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li>比特和字节的关系，8bit = 1B</li><li>十六进制数的表达方式以及十六进制数和二进制数的转换<ul><li>例子：0x2f = 00101111</li></ul></li></ul><h3 id=预习内容 class=heading-element><span>预习内容</span>
<a href=#%e9%a2%84%e4%b9%a0%e5%86%85%e5%ae%b9 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h3 id=1-中央处理器cpu架构 class=heading-element><span>1. 中央处理器（CPU）架构</span>
<a href=#1-%e4%b8%ad%e5%a4%ae%e5%a4%84%e7%90%86%e5%99%a8cpu%e6%9e%b6%e6%9e%84 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h5 id=内存 class=heading-element><span>内存</span>
<a href=#%e5%86%85%e5%ad%98 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>内存是计算机的存储空间。</p><p>对于很多没有接触过计算机的人来说，内存=硬盘。其实这种理解是错误的。内存掉电会丢失内容，而
硬盘在掉电之后信息不会丢失。但是内存的访问速度比硬盘快，因此实际上在电脑启动时操作系统的代码
会从硬盘上搬迁到内存里。平时打开的文件也是如此。</p><p>内存地址的基本单位是字节。一个字节=8比特。对于32位计算机，其寻址能力为32位，意思是有2^32个
地址。大部分计算机是字节寻址，即一个地址对应一个字节的数据（ECE120涉及的LC3是16位机，但是
一个地址对应2B两个字节的数据）。</p><h5 id=其他 class=heading-element><span>其他</span>
<a href=#%e5%85%b6%e4%bb%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>交给ECE120去学吧。</p><h3 id=2-编译流程 class=heading-element><span>2. 编译流程</span>
<a href=#2-%e7%bc%96%e8%af%91%e6%b5%81%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><h4 id=常见概念 class=heading-element><span>常见概念</span>
<a href=#%e5%b8%b8%e8%a7%81%e6%a6%82%e5%bf%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>头文件<code>.h</code>包含了函数声明、宏定义等。在C++当中还会存放类。<code>.c</code>文件中存放源代码。</p><h4 id=具体流程 class=heading-element><span>具体流程</span>
<a href=#%e5%85%b7%e4%bd%93%e6%b5%81%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><h5 id=a预处理阶段 class=heading-element><span>(a)预处理阶段</span>
<a href=#a%e9%a2%84%e5%a4%84%e7%90%86%e9%98%b6%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>预处理阶段，其实用朴素的话语来讲就是对宏（Macro）进行文本替换或展开。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span></span></span></code></pre></td></tr></table></div></div><p>在预处理完成之后，这段代码会被直接替换位<code>stdio.h</code>头文件包含的内容。
再例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cp>#define GPIO_DEVICE_ID 1</span></span></span></code></pre></td></tr></table></div></div><p>代码里所有出现的<code>GPIO_DEVICE_ID</code>将被替换为1。</p><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-lightbulb fa-fw" aria-hidden=true></i>注意<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>当使用<code>#include</code>之后，就可以使用头文件里的宏。除非是编译器定义的宏，否则可能会无法被找到。</div></div></div><h5 id=b编译阶段 class=heading-element><span>(b)编译阶段</span>
<a href=#b%e7%bc%96%e8%af%91%e9%98%b6%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>将所有预处理之后的C/C++代码翻译成汇编语言(汇编文件一般以<code>.s</code>,<code>.asm</code>为后缀，将会在ECE120
后期课程涉及)。</p><h5 id=c汇编阶段 class=heading-element><span>(c)汇编阶段</span>
<a href=#c%e6%b1%87%e7%bc%96%e9%98%b6%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>将汇编语言翻译成计算机可执行的二进制文件(生成若干<code>.o</code>，<code>.obj</code>文件)。每个独立的二进制文件
由于不知道相互之间的关系，现在还无法独立运行。</p><h5 id=d链接阶段 class=heading-element><span>(d)链接阶段</span>
<a href=#d%e9%93%be%e6%8e%a5%e9%98%b6%e6%ae%b5 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h5><p>这个阶段是最令人头大阶段。链接过程将多个目标文以及所需的库文件(.so等)链接成最终的可执行文件
(executable file)。该过程较为复杂，希望详细了解可以阅读<a href=https://zhuanlan.zhihu.com/p/88255667 target=_blank rel="external nofollow noopener noreferrer">知乎文章</a>。
通俗易懂的讲法，就是把每个C/C++文件生成的二进制文件，或者一些厂商（例如Windows）提供的
二进制文件（即静态与动态链接库，常见后缀<code>.so</code>，<code>.lib</code>，<code>.a</code>）组装在一起。</p><p><strong>静态链接库</strong>：当要使用时，连接器(linker)会找出程序所需的函数，然后将它们拷贝到执行文件，
由于这种拷贝是完整的，所以一旦连接成功，静态程序库也就不再需要了。</p><p><strong>动态库链接库</strong>：某个程序在运行中要调用某个动态链接库函数的时候，操作系统首先会查看所有正在运行的程序，看在内存里是否已有此库函数的拷贝了。
如果有，则让其共享那一个拷贝；只有没有才链接载入</p><p><strong>常见错误</strong>：</p><p>如果使用一个函数但没有定义它（大部分时候有可能是函数单纯打错了）：<div class="details admonition failure open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-times-circle fa-fw" aria-hidden=true></i>Failure<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>link_example.c:(.text+0xe): undefined reference to `foo'
collect2.exe: error: ld returned 1 exit status</div></div></div></p><p>如果链接器发现了两个不同的二进制文件中有相同的全局变量或函数，连接器会这么报错：<div class="details admonition failure open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-times-circle fa-fw" aria-hidden=true></i>Failure<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>/tmp/ccIa32rv.o:(.bss+0x0): multiple definition of <code>head'/tmp/ccAvumDO.o:(.bss+0x0): first defined here /tmp/ccuVImET.o:(.bss+0x0): multiple definition of </code>head'
/tmp/ccAvumDO.o:(.bss+0x0): first defined here
collect2: error: ld returned 1 exit status</div></div></div></p><h3 id=3-编译脚本 class=heading-element><span>3. 编译脚本</span>
<a href=#3-%e7%bc%96%e8%af%91%e8%84%9a%e6%9c%ac class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>脚本(sript)就是把一些命令放在一个文件里，这样在执行的时候不需要一条条手动输入而是一次性
全部执行的一个文件。</p><p>编程语言也主要分为两种：编译语言与脚本语言。脚本语言的每一条代码逐条投喂至解释器，并理解
翻译成二进制代码供CPU执行。而编译语言将全部代码全部翻译为二进制代码之后才能供CPU执行。
最常见的脚本语言是Python。最典型的编译语言即为C和C++。</p><h4 id=makefile class=heading-element><span>Makefile</span>
<a href=#makefile class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>Makefile 是一个用于管理项目构建的文件，通常用于编译和链接程序，特别是在大型项目中。
它通过定义一系列规则和目标，自动化了编译和构建过程，从而避免了手动输入复杂的编译命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Makefile data-lang=Makefile><span class=line><span class=cl><span class=c># 定义变量
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>CC</span> <span class=o>=</span> gcc
</span></span><span class=line><span class=cl><span class=nv>CFLAGS</span> <span class=o>=</span> -Wall -g
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 定义目标文件
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>TARGET</span> <span class=o>=</span> myprogram
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 定义依赖关系和规则
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>$(TARGET)</span><span class=o>:</span> <span class=n>main</span>.<span class=n>o</span> <span class=n>utils</span>.<span class=n>o</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -o <span class=k>$(</span>TARGET<span class=k>)</span> main.o utils.o
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>main.o</span><span class=o>:</span> <span class=n>main</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -c main.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>utils.o</span><span class=o>:</span> <span class=n>utils</span>.<span class=n>c</span>
</span></span><span class=line><span class=cl>    <span class=k>$(</span>CC<span class=k>)</span> <span class=k>$(</span>CFLAGS<span class=k>)</span> -c utils.c
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c># 伪目标，用于清理构建文件
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nf>.PHONY</span><span class=o>:</span> <span class=n>clean</span>
</span></span><span class=line><span class=cl><span class=nf>clean</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    rm -f <span class=k>$(</span>TARGET<span class=k>)</span> *.o
</span></span></code></pre></td></tr></table></div></div><p>找到项目的Makefile文件，打开终端输入：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>make</span></span></code></pre></td></tr></table></div></div><p><code>make</code>将根据Makefile生成<code>gcc</code>指令。例如上述代码的运行路径为中的文件有：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>my_project/
</span></span><span class=line><span class=cl>├── Makefile
</span></span><span class=line><span class=cl>├── main.c
</span></span><span class=line><span class=cl>└── utils.c</span></span></code></pre></td></tr></table></div></div><p>$(CC)会被翻译成gcc，$(CFLAGS)会被翻译成-Wall -g。-o 我们在之前介绍过，是输出的意思。
所以如果输入<code>make myprogram</code>实际上相当于输入了以下的gcc指令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>gcc -Wall -g -c main.c <span class=c1># 将main.c编译为main.o</span>
</span></span><span class=line><span class=cl>gcc -Wall -g -c utils.c
</span></span><span class=line><span class=cl>gcc -Wall -g -o myprogram main.o utils.o <span class=c1># 通过.o文件生成myprogram可执行文件</span></span></span></code></pre></td></tr></table></div></div><h4 id=cmake class=heading-element><span>CMake</span>
<a href=#cmake class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h4><p>CMake 是一个跨台的构建系统，它用于管理项目的编译过程，生成特定于平台的构建文件（如
Makefile、Visual Studio 项目文件等）。CMake 通过一种高级脚本语言来描述构建过程，
能够更好地处理复杂的构建需求，并且在不同平台之间保持一致性。在我们的项目中我们一般使用
Cmake来生成Makefile。</p><p>假设现在我们的项目文件夹为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>my_project/
</span></span><span class=line><span class=cl>├── CMakeLists.txt
</span></span><span class=line><span class=cl>├── main.cpp
</span></span><span class=line><span class=cl>└── utils.cpp</span></span></code></pre></td></tr></table></div></div><p><code>CMakeLists.txt</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cmake data-lang=cmake><span class=line><span class=cl><span class=nb>cmake_minimum_required</span><span class=p>(</span><span class=s>VERSION</span> <span class=s>3.10</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 项目信息
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nb>project</span><span class=p>(</span><span class=s>MyProject</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 设置 C++ 标准
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_CXX_STANDARD</span> <span class=s>11</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nb>set</span><span class=p>(</span><span class=s>CMAKE_CXX_STANDARD_REQUIRED</span> <span class=s>True</span><span class=p>)</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 添加可执行文件
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nb>add_executable</span><span class=p>(</span><span class=s>MyProject</span> <span class=s>main.cpp</span> <span class=s>utils.cpp</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><p>然后运行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>mkdir build
</span></span><span class=line><span class=cl><span class=nb>cd</span> build
</span></span><span class=line><span class=cl>cmake ..  <span class=c1># .. 表示上一级目录，这里的意思是Cmakelists.txt在上一级目录</span></span></span></code></pre></td></tr></table></div></div><p>然后我们就能在build文件夹中找到Makefile了。此时我们就能运行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>make</span></span></code></pre></td></tr></table></div></div><p>我们就能得到想要的二进制可执行文件了。</p><h3 id=课后作业 class=heading-element><span>课后作业</span>
<a href=#%e8%af%be%e5%90%8e%e4%bd%9c%e4%b8%9a class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><ul><li>使用Makefile和Cmake成功编译文件。</li><li>继续观看黑马程序员教学视频。</li></ul><hr class=awesome-hr></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="Updated on 2024-05-16 00:08:52">Updated on 2024-05-16&nbsp;</span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/bd7db78/index.md title="Read Markdown" class=link-to-markdown>Read Markdown</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://Raventhatfly.github.io/posts/bd7db78/ data-title=Lecture2><i data-svg-src=/lib/simple-icons/icons/line.min.svg aria-hidden=true></i></a>
<a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://Raventhatfly.github.io/posts/bd7db78/ data-title=Lecture2><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="Share on Myspace" data-sharer=myspace data-url=https://Raventhatfly.github.io/posts/bd7db78/ data-title=Lecture2 data-description><i data-svg-src=/lib/simple-icons/icons/myspace.min.svg aria-hidden=true></i></a>
<a href=javascript:void(0); title="Share on Blogger" data-sharer=blogger data-url=https://Raventhatfly.github.io/posts/bd7db78/ data-title=Lecture2 data-description><i class="fa-brands fa-blogger fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="Share on Evernote" data-sharer=evernote data-url=https://Raventhatfly.github.io/posts/bd7db78/ data-title=Lecture2><i class="fa-brands fa-evernote fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw me-1" aria-hidden=true></i><a href=/tags/meta-teaching/ class=post-tag title="Tags - Meta-Teaching">Meta-Teaching</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/574de11/ class=post-nav-item rel=prev title=Lecture1><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Lecture1</a>
<a href=/posts/2e8f072/ class=post-nav-item rel=next title=Lecture3>Lecture3<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article><aside class=toc id=toc-auto aria-label=Contents><h2 class=toc-title>Contents&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside></main><footer class=footer><div class=footer-container><div class="footer-line powered">Powered by <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.125.7"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> | Theme - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.3.6"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2024</span><span class=author itemprop=copyrightHolder>
<a href=/>Feiyang Wu</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><a href=https://github.com/Raventhatfly title="View source on GitHub" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:black;--bg-progress-dark:red></div><noscript><div class=noscript-warning>Theme FixIt works best with JavaScript enabled.</div></noscript></div><script src=/lib/sharer/sharer.min.js async defer></script><script>window.config={code:{copyTitle:"Copy to clipboard",editLockTitle:"Lock editable code block",editUnLockTitle:"Unlock editable code block",editable:!0,maxShownLines:10},comment:{enable:!1},version:"v0.3.6"}</script><script src=/js/theme.min.js defer></script></body></html>